/*
The *VAST* majority of the functions in this file are from the amazing
Inigo Quilez, specifically their page on SDF distance functions:
https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
*/

const int LIT = 0;
const int BOX = LIT + 1;
const int OCTOHEDRON_B = BOX + 1;
const int PLANE = OCTOHEDRON_B + 1;
const int SPHERE = PLANE + 1;
const int UNION = SPHERE + 1;
const int NEG = UNION + 1;
const int ROT = NEG + 1;
const int TRANS = ROT + 1;
const int TIME = TRANS + 1;
// Always should be last
const int BASE_MATERIAL = TIME + 1;

struct sdf_result_t {
	float dist;
	mat_t closest_material;
};

// This kinda breaks
vec3 twist_sdf(vec3 p) {
	const float k = 2.0;
	float c = cos(k * p.y);
	float s = sin(k * p.y);
	mat2 m = mat2(c, -s, s, c);
	vec3 q = vec3(m * p.xz, p.y);

	return q;
}

// Using this crashes
vec3 repeat_inf_sdf(vec3 p, vec3 c) {
	return mod(p + 0.5 * c, c) - 0.5 * c;
}

vec3 repeat_lim_sdf(vec3 p, float c, vec3 l) {
	return p - c * clamp(round(p / c), -l, l);
}

float neg_sdf(float s) {
	return -s;
}

sdf_result_t neg_sdf(sdf_result_t s) {
	return sdf_result_t(neg_sdf(s.dist), s.closest_material);
}

float sub_sdf(float a, float b) {
	return max(-a, b);
}

sdf_result_t sub_sdf(sdf_result_t a, sdf_result_t b) {
	return sdf_result_t(sub_sdf(a.dist, b.dist), b.closest_material);
}

float union_sdf(float a, float b) {
	return min(a, b);
}

sdf_result_t union_sdf(sdf_result_t a, sdf_result_t b) {
	return sdf_result_t(union_sdf(a.dist, b.dist), a.dist < b.dist ? a.closest_material : b.closest_material);
}

float smooth_union_sdf(float k, float a, float b) {
	float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

sdf_result_t smooth_union_sdf(float k, sdf_result_t a, sdf_result_t b) {
	return sdf_result_t(smooth_union_sdf(k, a.dist, b.dist), a.dist < b.dist ? a.closest_material : b.closest_material);
}

float sphere_sdf(vec3 p, float radius) {
	return length(p) - radius;
}

float box_sdf(vec3 p, vec3 bounds) {
	vec3 q = abs(p) - bounds;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float box_sdf(vec3 p, float x, float y, float z) {
	return box_sdf(p, vec3(x, y, z));
}

float octahedron_bound_sdf(vec3 p, float s) {
	p = abs(p);
	return (p.x + p.y + p.z - s) * 0.57735027;
}

float torus_sdf(vec3 p, vec2 t) {
	vec2 q = vec2(length(p.xz) - t.x, p.y);
	return length(q) - t.y;
}

float plane_sdf(vec3 p, vec3 n, float h) {
	return dot(p, n) + h;
}

float plane_sdf(vec3 p, float nx, float ny, float nz, float h) {
	return plane_sdf(p, vec3(nx, ny, nz), h);
}

mat3 rotation_matrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         );
}

vec3 rtrans(vec3 p, float x, float y, float z) {
	return p - vec3(x, y, z);
}

vec3 rrot(vec3 p, float ax, float ay, float az, float angle) {
	return (inverse(rotation_matrix(vec3(ax, ay, az), angle)) * p);
}

sdf_result_t compiled_scene_sdf(vec3 p) {
