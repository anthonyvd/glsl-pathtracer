void main() {
	global_lcg = init_lcg(hash(frame_count ^ hash(floatBitsToUint(gl_FragCoord.x)) ^ hash(floatBitsToUint(gl_FragCoord.y))));

	camera_t c = create_camera(kOrigin, kLookAt, kUp, kAspectRatio, 60.0);

	vec3 color_accumulator = texture2D(partial_render, vec2(gl_FragCoord.x / float(width), gl_FragCoord.y / float(height))).xyz;
	color_accumulator *= color_accumulator;
	color_accumulator *= (samples_in_image - samples_per_round);

	for (int i = 0; i < samples_per_round; ++i) {
		float du = rfloat();
		float dv = rfloat();

		float u = (gl_FragCoord.x + du) / (width - 1.0);
		float v = (gl_FragCoord.y + dv) / (height - 1.0);
		ray_t r = shoot_ray(c, u, v);

		vec3 path_color = vec3(0);
		int current_depth = 0;
		vec3 attenuation = vec3(1.0);

		while (current_depth < kMaxDepth) {
			hit_t hit = hit_t(false, vec3(0), vec3(0), kTMax, false, make_no_material(), vec3(0), vec3(0));
			/* 
			for (int i = 0; i < kSpheres.length(); ++i) {
				hit_t h = hit_sphere(kTMin, kTMax, kSpheres[i], r);
				if (h.hit && h.t < hit.t)
					hit = h;
			}*/
			
			float march_dist = 0;
			for (int i = 0; i < kMaxRaymarchSteps && march_dist <= kTMax; ++i) {
				hit_t h = eval_sdf(r, march_dist);
				if (h.hit && h.t < hit.t) {
					hit = h;
					break;
				}

				march_dist += abs(h.t);
			}

			if (hit.hit) {
				vec3 norm = hit.normal;
				// Color according to normals:
				//path_color = 0.5 * vec3(norm.x + 1, norm.y + 1, norm.z + 1);
				
				scatter_t s = scatter(r, hit);
				if (s.scattered) {
					r = s.scattered_ray;
					attenuation *= s.attenuation;
				} else {
					path_color = s.emitter_color;
					break;
				}
			} else {
				// blue gradient background
				/*float t = 0.5 * (r.direction.y + 1.0);
				path_color = (1.0 - t) * vec3(1, 1, 1) + t * vec3(0.5, 0.7, 1.0);*/
				path_color = vec3(0);
				break;
			}

			current_depth++;
		}

		color_accumulator += (attenuation * path_color);
	}

	float total_samples = samples_in_image;

	vec3 col = sqrt(color_accumulator / total_samples);
	color = vec4(col, 1.0);
}